---
title: "Double Tumor CNN"
output:
  html_document: default
  pdf_document: default
date: "2023-04-12"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Upload Images
```{r}
library(reticulate)
use_condaenv("tf")
library(tensorflow)
```

SBrainTumorClass combines the original testing and training into a single file.
```{r}
library(jpeg)
library(magick)
#List of no_tumor files
path <- "C:/Users/Oscar/Downloads/SBrainTumorClass/no_tumor/"
files <- list.files(path=path, pattern=".jpg") 
no.tumor <- list(rep(0,length(files)))
for(i in 1:length(files)){
  img = image_read(paste0(path,files[i]))
  img = image_scale(img,"224x224!")
  no.tumor[[i]] <- readJPEG(image_write(img))
}

#glioma_tumor
path <- "C:/Users/Oscar/Downloads/SBrainTumorClass/glioma_tumor/"
files <- list.files(path=path, pattern=".jpg") 
glioma.tumor <- list(rep(0,length(files)))
for(i in 1:length(files)){
  img = image_read(paste0(path,files[i]))
  img = image_scale(img,"224x224!")
  glioma.tumor[[i]] <- readJPEG(image_write(img))
}

#meningioma_tumor
path <- "C:/Users/Oscar/Downloads/SBrainTumorClass/meningioma_tumor/"
files <- list.files(path=path, pattern=".jpg") 
meningioma.tumor <- list(rep(0,length(files)))
for(i in 1:length(files)){
  img = image_read(paste0(path,files[i]))
  img = image_scale(img,"224x224!")
  meningioma.tumor[[i]] <- readJPEG(image_write(img))
}

#pituitary_tumor
path <- "C:/Users/Oscar/Downloads/SBrainTumorClass/pituitary_tumor/"
files <- list.files(path=path, pattern=".jpg") 
pituitary.tumor <- list(rep(0,length(files)))
for(i in 1:length(files)){
  img = image_read(paste0(path,files[i]))
  img = image_scale(img,"224x224!")
  pituitary.tumor[[i]] <- readJPEG(image_write(img))
}
```

Seed ensures training and testing never mix.
```{r}
set.seed(10)
tumor.list = c(no.tumor,glioma.tumor,meningioma.tumor,pituitary.tumor)
reorder = sample(length(tumor.list))
tumor = array(dim=c(length(tumor.list),224,224,3))
for(i in 1:length(tumor.list)){
  tumor[i,,,1] = tumor.list[[reorder[i]]]
  tumor[i,,,2] = tumor.list[[reorder[i]]]
  tumor[i,,,3] = tumor.list[[reorder[i]]]
}

# no_tumor = 0
# tumor = 1
tumor.classes = c(rep(0,length(no.tumor)),
                rep(1,length(glioma.tumor)),
                rep(1,length(meningioma.tumor)),
                rep(1,length(pituitary.tumor)))
tumor.class = rep(NA,length(tumor.classes))
for(i in 1:length(tumor.list)){
  tumor.class[i] = tumor.classes[reorder[i]]
}

tumor.train = tumor[1:2528,,,]
tumor.test = tumor[2529:3160,,,]
class.train = tumor.class[1:2528]
class.test = tumor.class[2529:3160]
```

## First CNN Structure

```{r,eval=FALSE}
library(keras)
resnet.kernel <- application_resnet50_v2(include_top = FALSE,
                        weights = "imagenet")

dense <- resnet.kernel$output %>%
  layer_global_average_pooling_2d() %>%
  layer_dense(units=1024, activation = "relu") %>%
  layer_batch_normalization() %>%
  layer_dropout(rate=0.25) %>%
  layer_dense(units = 2, activation = "softmax")
  
cnn.tumorii <- keras_model(inputs = resnet.kernel$input,
                           outputs = dense)
freeze_weights(resnet.kernel)

# summary(cnn.tumorii)

es = callback_early_stopping(monitor = "val_loss",
                        min_delta = 0,
                        patience = 3,
                        restore_best_weights = TRUE)

cnn.tumorii %>% compile(
  loss = "sparse_categorical_crossentropy",
  optimizer = optimizer_adam(learning_rate=0.0001),
  metrics = c("accuracy")
)

historyii <- cnn.tumorii %>% fit(
  tumor.train, class.train,
  batch_size = 32,
  epochs = 16,
  validation_split = 0.2,
  callback = es
)
plot(historyii)
```

```{r}
library(keras)
# cnn.tumorii %>% save_model_tf("cnn_no.tumor")
cnn.no.tumor = load_model_tf("cnn_no.tumor")
cnn.predict = predict(cnn.no.tumor,tumor.test)
cnn.class = apply(cnn.predict,1,which.max)-1
# Tumor/No Tumor Classification Accuracy
mean(ifelse(cnn.class==class.test,1,0))
```

```{r}
# Train only on positive tumors
tumor.train = tumor.train[class.train!=0,,,]

# Consider which test set is classified as positive
tumor.testii <- tumor.test[ifelse(cnn.class==1,T,F),,,]

# no_tumor = 0
# glioma_tumor = 1
# meningioma_tumor = 2
# pituitary_tumor = 3
tumor.classes = c(rep(0,length(no.tumor)),
                rep(1,length(glioma.tumor)),
                rep(2,length(meningioma.tumor)),
                rep(3,length(pituitary.tumor)))
tumor.class = rep(NA,length(tumor.classes))
for(i in 1:length(tumor.list)){
  tumor.class[i] = tumor.classes[reorder[i]]
}

# Training set should only have positive tumors
class.train = tumor.class[1:2528]
class.train = class.train[class.train!=0]-1
# Testing set has final classfications
class.test = tumor.class[2529:3160]
class.testii = class.test[ifelse(cnn.class==1,T,F)]
```

## Second CNN Structure

```{r, eval=FALSE}
library(keras)

cnn.tumoriii <- keras_model_sequential() %>%
  layer_conv_2d(filters = 32, kernel_size = c(3,3), activation = "relu",
                padding = "same", input_shape = c(112,112,1)) %>%
  layer_max_pooling_2d(pool_size = c(2,2)) %>%
  layer_batch_normalization()%>%
  layer_conv_2d(filters = 64, kernel_size = c(3,3), activation = "relu",
                padding = "same") %>%
  layer_max_pooling_2d(pool_size = c(2,2)) %>%
  layer_batch_normalization()%>%
  layer_conv_2d(filters = 128, kernel_size = c(3,3), activation = "relu",
                padding = "same") %>%
  layer_max_pooling_2d(pool_size = c(2,2)) %>%
  layer_batch_normalization()%>%
  layer_conv_2d(filters = 256, kernel_size = c(3,3), activation = "relu",
                padding = "same") %>%
  layer_max_pooling_2d(pool_size = c(2,2)) %>%
  layer_batch_normalization()%>%
  layer_global_average_pooling_2d() %>%
  layer_dense(units=128, activation = "relu") %>%
  layer_batch_normalization()%>%
  layer_dropout(rate=0.2) %>%
  layer_dense(units = 3, activation = "softmax")
# summary(cnn.tumoriii)

cnn.tumoriii %>% compile(
  loss = "sparse_categorical_crossentropy",
  optimizer = optimizer_adam(learning_rate = 0.0001),
  metrics = c("accuracy")
)

es = callback_model_checkpoint("cnn_which.tumor",
                        monitor = "val_loss",
                        save_best_only = TRUE)

historyiii <- cnn.tumoriii %>% fit(
  layer_max_pooling_2d(tumor.train)[,,,1],
  class.train,
  batch_size = 32,
  epochs = 32,
  validation_split = 0.1,
  callback = es
)
plot(historyiii)
```

```{r}
cnn.which.tumor = load_model_tf("cnn_which.tumor")
cnn.predict = predict(cnn.which.tumor,
                      layer_max_pooling_2d(tumor.testii)[,,,1])
cnn.classii = apply(cnn.predict,1,which.max)
# Positive Tumor Classfication Rate
mean(ifelse(cnn.classii==class.testii,1,0))
```

```{r}
j = 1
for(i in 1:length(cnn.class)){
  if(cnn.class[i] != 0){
    cnn.class[i] = cnn.classii[j]
    j = j+1
  }
}
#Overall Accuracy
mean(ifelse(cnn.class==class.test,1,0))
```
```{r}
# No Tumor Accuracy
mean(ifelse(cnn.class[which(class.test==0)]==
              class.test[which(class.test==0)],1,0))
# Glioma Accuracy
mean(ifelse(cnn.class[which(class.test==1)]==
              class.test[which(class.test==1)],1,0))
# Meningioma Accuracy
mean(ifelse(cnn.class[which(class.test==2)]==
              class.test[which(class.test==2)],1,0))
# Pituitary Accuracy
mean(ifelse(cnn.class[which(class.test==3)]==
              class.test[which(class.test==3)],1,0))

```

